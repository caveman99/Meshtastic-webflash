<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: mesh.proto

namespace Routing;

use UnexpectedValueException;

/**
 * A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
 * details on the type of failure).
 *
 * Protobuf type <code>Routing.Error</code>
 */
class Error
{
    /**
     * This message is not a failure
     *
     * Generated from protobuf enum <code>NONE = 0;</code>
     */
    const NONE = 0;
    /**
     * Our node doesn't have a route to the requested destination anymore.
     *
     * Generated from protobuf enum <code>NO_ROUTE = 1;</code>
     */
    const NO_ROUTE = 1;
    /**
     * We received a nak while trying to forward on your behalf
     *
     * Generated from protobuf enum <code>GOT_NAK = 2;</code>
     */
    const GOT_NAK = 2;
    /**
     * TODO: REPLACE
     *
     * Generated from protobuf enum <code>TIMEOUT = 3;</code>
     */
    const TIMEOUT = 3;
    /**
     * No suitable interface could be found for delivering this packet
     *
     * Generated from protobuf enum <code>NO_INTERFACE = 4;</code>
     */
    const NO_INTERFACE = 4;
    /**
     * We reached the max retransmission count (typically for naive flood routing)
     *
     * Generated from protobuf enum <code>MAX_RETRANSMIT = 5;</code>
     */
    const MAX_RETRANSMIT = 5;
    /**
     * No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
     *
     * Generated from protobuf enum <code>NO_CHANNEL = 6;</code>
     */
    const NO_CHANNEL = 6;
    /**
     * The packet was too big for sending (exceeds interface MTU after encoding)
     *
     * Generated from protobuf enum <code>TOO_LARGE = 7;</code>
     */
    const TOO_LARGE = 7;
    /**
     * The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
     * (possibly due to bad channel permissions)
     *
     * Generated from protobuf enum <code>NO_RESPONSE = 8;</code>
     */
    const NO_RESPONSE = 8;
    /**
     * Cannot send currently because duty cycle regulations will be violated.
     *
     * Generated from protobuf enum <code>DUTY_CYCLE_LIMIT = 9;</code>
     */
    const DUTY_CYCLE_LIMIT = 9;
    /**
     * The application layer service on the remote node received your request, but considered your request somehow invalid
     *
     * Generated from protobuf enum <code>BAD_REQUEST = 32;</code>
     */
    const BAD_REQUEST = 32;
    /**
     * The application layer service on the remote node received your request, but considered your request not authorized
     * (i.e you did not send the request on the required bound channel)
     *
     * Generated from protobuf enum <code>NOT_AUTHORIZED = 33;</code>
     */
    const NOT_AUTHORIZED = 33;

    private static $valueToName = [
        self::NONE => 'NONE',
        self::NO_ROUTE => 'NO_ROUTE',
        self::GOT_NAK => 'GOT_NAK',
        self::TIMEOUT => 'TIMEOUT',
        self::NO_INTERFACE => 'NO_INTERFACE',
        self::MAX_RETRANSMIT => 'MAX_RETRANSMIT',
        self::NO_CHANNEL => 'NO_CHANNEL',
        self::TOO_LARGE => 'TOO_LARGE',
        self::NO_RESPONSE => 'NO_RESPONSE',
        self::DUTY_CYCLE_LIMIT => 'DUTY_CYCLE_LIMIT',
        self::BAD_REQUEST => 'BAD_REQUEST',
        self::NOT_AUTHORIZED => 'NOT_AUTHORIZED',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(Error::class, \Routing_Error::class);

