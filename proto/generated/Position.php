<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: mesh.proto

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 *
 * a gps position
 *
 * Generated from protobuf message <code>Position</code>
 */
class Position extends \Google\Protobuf\Internal\Message
{
    /**
     *
     * The new preferred location encoding, divide by 1e-7 to get degrees
     * in floating point
     *
     * Generated from protobuf field <code>sfixed32 latitude_i = 1;</code>
     */
    private $latitude_i = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>sfixed32 longitude_i = 2;</code>
     */
    private $longitude_i = 0;
    /**
     *
     * In meters above MSL (but see issue #359)
     *
     * Generated from protobuf field <code>int32 altitude = 3;</code>
     */
    private $altitude = 0;
    /**
     *
     * This is usually not sent over the mesh (to save space), but it is sent
     * from the phone so that the local device can set its RTC If it is sent over
     * the mesh (because there are devices on the mesh without GPS), it will only
     * be sent by devices which has a hardware GPS clock.
     * seconds since 1970
     *
     * Generated from protobuf field <code>fixed32 time = 4;</code>
     */
    private $time = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.LocSource location_source = 5;</code>
     */
    private $location_source = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.AltSource altitude_source = 6;</code>
     */
    private $altitude_source = 0;
    /**
     *
     * Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
     *
     * Generated from protobuf field <code>fixed32 timestamp = 7;</code>
     */
    private $timestamp = 0;
    /**
     *
     * Pos. timestamp milliseconds adjustment (rarely available or required)
     *
     * Generated from protobuf field <code>int32 timestamp_millis_adjust = 8;</code>
     */
    private $timestamp_millis_adjust = 0;
    /**
     *
     * HAE altitude in meters - can be used instead of MSL altitude
     *
     * Generated from protobuf field <code>sint32 altitude_hae = 9;</code>
     */
    private $altitude_hae = 0;
    /**
     *
     * Geoidal separation in meters
     *
     * Generated from protobuf field <code>sint32 altitude_geoidal_separation = 10;</code>
     */
    private $altitude_geoidal_separation = 0;
    /**
     *
     * Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
     * - PDOP is sufficient for most cases
     * - for higher precision scenarios, HDOP and VDOP can be used instead,
     *   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 PDOP = 11;</code>
     */
    private $PDOP = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 HDOP = 12;</code>
     */
    private $HDOP = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 VDOP = 13;</code>
     */
    private $VDOP = 0;
    /**
     *
     * GPS accuracy (a hardware specific constant) in mm
     *   multiplied with DOP to calculate positional accuracy
     * Default: "'bout three meters-ish" :)
     *
     * Generated from protobuf field <code>uint32 gps_accuracy = 14;</code>
     */
    private $gps_accuracy = 0;
    /**
     *
     * Ground speed in m/s and True North TRACK in 1/100 degrees
     * Clarification of terms:
     * - "track" is the direction of motion (measured in horizontal plane)
     * - "heading" is where the fuselage points (measured in horizontal plane)
     * - "yaw" indicates a relative rotation about the vertical axis
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 ground_speed = 15;</code>
     */
    private $ground_speed = 0;
    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 ground_track = 16;</code>
     */
    private $ground_track = 0;
    /**
     *
     * GPS fix quality (from NMEA GxGGA statement or similar)
     *
     * Generated from protobuf field <code>uint32 fix_quality = 17;</code>
     */
    private $fix_quality = 0;
    /**
     *
     * GPS fix type 2D/3D (from NMEA GxGSA statement)
     *
     * Generated from protobuf field <code>uint32 fix_type = 18;</code>
     */
    private $fix_type = 0;
    /**
     *
     * GPS "Satellites in View" number
     *
     * Generated from protobuf field <code>uint32 sats_in_view = 19;</code>
     */
    private $sats_in_view = 0;
    /**
     *
     * Sensor ID - in case multiple positioning sensors are being used
     *
     * Generated from protobuf field <code>uint32 sensor_id = 20;</code>
     */
    private $sensor_id = 0;
    /**
     *
     * Estimated/expected time (in seconds) until next update:
     * - if we update at fixed intervals of X seconds, use X
     * - if we update at dynamic intervals (based on relative movement etc),
     *   but "AT LEAST every Y seconds", use Y
     *
     * Generated from protobuf field <code>uint32 next_update = 21;</code>
     */
    private $next_update = 0;
    /**
     *
     * A sequence number, incremented with each Position message to help
     *   detect lost updates if needed
     *
     * Generated from protobuf field <code>uint32 seq_number = 22;</code>
     */
    private $seq_number = 0;

    public function __construct() {
        \GPBMetadata\Mesh::initOnce();
        parent::__construct();
    }

    /**
     *
     * The new preferred location encoding, divide by 1e-7 to get degrees
     * in floating point
     *
     * Generated from protobuf field <code>sfixed32 latitude_i = 1;</code>
     * @return int
     */
    public function getLatitudeI()
    {
        return $this->latitude_i;
    }

    /**
     *
     * The new preferred location encoding, divide by 1e-7 to get degrees
     * in floating point
     *
     * Generated from protobuf field <code>sfixed32 latitude_i = 1;</code>
     * @param int $var
     * @return $this
     */
    public function setLatitudeI($var)
    {
        GPBUtil::checkInt32($var);
        $this->latitude_i = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>sfixed32 longitude_i = 2;</code>
     * @return int
     */
    public function getLongitudeI()
    {
        return $this->longitude_i;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>sfixed32 longitude_i = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setLongitudeI($var)
    {
        GPBUtil::checkInt32($var);
        $this->longitude_i = $var;

        return $this;
    }

    /**
     *
     * In meters above MSL (but see issue #359)
     *
     * Generated from protobuf field <code>int32 altitude = 3;</code>
     * @return int
     */
    public function getAltitude()
    {
        return $this->altitude;
    }

    /**
     *
     * In meters above MSL (but see issue #359)
     *
     * Generated from protobuf field <code>int32 altitude = 3;</code>
     * @param int $var
     * @return $this
     */
    public function setAltitude($var)
    {
        GPBUtil::checkInt32($var);
        $this->altitude = $var;

        return $this;
    }

    /**
     *
     * This is usually not sent over the mesh (to save space), but it is sent
     * from the phone so that the local device can set its RTC If it is sent over
     * the mesh (because there are devices on the mesh without GPS), it will only
     * be sent by devices which has a hardware GPS clock.
     * seconds since 1970
     *
     * Generated from protobuf field <code>fixed32 time = 4;</code>
     * @return int
     */
    public function getTime()
    {
        return $this->time;
    }

    /**
     *
     * This is usually not sent over the mesh (to save space), but it is sent
     * from the phone so that the local device can set its RTC If it is sent over
     * the mesh (because there are devices on the mesh without GPS), it will only
     * be sent by devices which has a hardware GPS clock.
     * seconds since 1970
     *
     * Generated from protobuf field <code>fixed32 time = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setTime($var)
    {
        GPBUtil::checkUint32($var);
        $this->time = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.LocSource location_source = 5;</code>
     * @return int
     */
    public function getLocationSource()
    {
        return $this->location_source;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.LocSource location_source = 5;</code>
     * @param int $var
     * @return $this
     */
    public function setLocationSource($var)
    {
        GPBUtil::checkEnum($var, \Position_LocSource::class);
        $this->location_source = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.AltSource altitude_source = 6;</code>
     * @return int
     */
    public function getAltitudeSource()
    {
        return $this->altitude_source;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>.Position.AltSource altitude_source = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setAltitudeSource($var)
    {
        GPBUtil::checkEnum($var, \Position_AltSource::class);
        $this->altitude_source = $var;

        return $this;
    }

    /**
     *
     * Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
     *
     * Generated from protobuf field <code>fixed32 timestamp = 7;</code>
     * @return int
     */
    public function getTimestamp()
    {
        return $this->timestamp;
    }

    /**
     *
     * Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
     *
     * Generated from protobuf field <code>fixed32 timestamp = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setTimestamp($var)
    {
        GPBUtil::checkUint32($var);
        $this->timestamp = $var;

        return $this;
    }

    /**
     *
     * Pos. timestamp milliseconds adjustment (rarely available or required)
     *
     * Generated from protobuf field <code>int32 timestamp_millis_adjust = 8;</code>
     * @return int
     */
    public function getTimestampMillisAdjust()
    {
        return $this->timestamp_millis_adjust;
    }

    /**
     *
     * Pos. timestamp milliseconds adjustment (rarely available or required)
     *
     * Generated from protobuf field <code>int32 timestamp_millis_adjust = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setTimestampMillisAdjust($var)
    {
        GPBUtil::checkInt32($var);
        $this->timestamp_millis_adjust = $var;

        return $this;
    }

    /**
     *
     * HAE altitude in meters - can be used instead of MSL altitude
     *
     * Generated from protobuf field <code>sint32 altitude_hae = 9;</code>
     * @return int
     */
    public function getAltitudeHae()
    {
        return $this->altitude_hae;
    }

    /**
     *
     * HAE altitude in meters - can be used instead of MSL altitude
     *
     * Generated from protobuf field <code>sint32 altitude_hae = 9;</code>
     * @param int $var
     * @return $this
     */
    public function setAltitudeHae($var)
    {
        GPBUtil::checkInt32($var);
        $this->altitude_hae = $var;

        return $this;
    }

    /**
     *
     * Geoidal separation in meters
     *
     * Generated from protobuf field <code>sint32 altitude_geoidal_separation = 10;</code>
     * @return int
     */
    public function getAltitudeGeoidalSeparation()
    {
        return $this->altitude_geoidal_separation;
    }

    /**
     *
     * Geoidal separation in meters
     *
     * Generated from protobuf field <code>sint32 altitude_geoidal_separation = 10;</code>
     * @param int $var
     * @return $this
     */
    public function setAltitudeGeoidalSeparation($var)
    {
        GPBUtil::checkInt32($var);
        $this->altitude_geoidal_separation = $var;

        return $this;
    }

    /**
     *
     * Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
     * - PDOP is sufficient for most cases
     * - for higher precision scenarios, HDOP and VDOP can be used instead,
     *   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 PDOP = 11;</code>
     * @return int
     */
    public function getPDOP()
    {
        return $this->PDOP;
    }

    /**
     *
     * Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
     * - PDOP is sufficient for most cases
     * - for higher precision scenarios, HDOP and VDOP can be used instead,
     *   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 PDOP = 11;</code>
     * @param int $var
     * @return $this
     */
    public function setPDOP($var)
    {
        GPBUtil::checkUint32($var);
        $this->PDOP = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 HDOP = 12;</code>
     * @return int
     */
    public function getHDOP()
    {
        return $this->HDOP;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 HDOP = 12;</code>
     * @param int $var
     * @return $this
     */
    public function setHDOP($var)
    {
        GPBUtil::checkUint32($var);
        $this->HDOP = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 VDOP = 13;</code>
     * @return int
     */
    public function getVDOP()
    {
        return $this->VDOP;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 VDOP = 13;</code>
     * @param int $var
     * @return $this
     */
    public function setVDOP($var)
    {
        GPBUtil::checkUint32($var);
        $this->VDOP = $var;

        return $this;
    }

    /**
     *
     * GPS accuracy (a hardware specific constant) in mm
     *   multiplied with DOP to calculate positional accuracy
     * Default: "'bout three meters-ish" :)
     *
     * Generated from protobuf field <code>uint32 gps_accuracy = 14;</code>
     * @return int
     */
    public function getGpsAccuracy()
    {
        return $this->gps_accuracy;
    }

    /**
     *
     * GPS accuracy (a hardware specific constant) in mm
     *   multiplied with DOP to calculate positional accuracy
     * Default: "'bout three meters-ish" :)
     *
     * Generated from protobuf field <code>uint32 gps_accuracy = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setGpsAccuracy($var)
    {
        GPBUtil::checkUint32($var);
        $this->gps_accuracy = $var;

        return $this;
    }

    /**
     *
     * Ground speed in m/s and True North TRACK in 1/100 degrees
     * Clarification of terms:
     * - "track" is the direction of motion (measured in horizontal plane)
     * - "heading" is where the fuselage points (measured in horizontal plane)
     * - "yaw" indicates a relative rotation about the vertical axis
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 ground_speed = 15;</code>
     * @return int
     */
    public function getGroundSpeed()
    {
        return $this->ground_speed;
    }

    /**
     *
     * Ground speed in m/s and True North TRACK in 1/100 degrees
     * Clarification of terms:
     * - "track" is the direction of motion (measured in horizontal plane)
     * - "heading" is where the fuselage points (measured in horizontal plane)
     * - "yaw" indicates a relative rotation about the vertical axis
     * TODO: REMOVE/INTEGRATE
     *
     * Generated from protobuf field <code>uint32 ground_speed = 15;</code>
     * @param int $var
     * @return $this
     */
    public function setGroundSpeed($var)
    {
        GPBUtil::checkUint32($var);
        $this->ground_speed = $var;

        return $this;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 ground_track = 16;</code>
     * @return int
     */
    public function getGroundTrack()
    {
        return $this->ground_track;
    }

    /**
     *
     * TODO: REPLACE
     *
     * Generated from protobuf field <code>uint32 ground_track = 16;</code>
     * @param int $var
     * @return $this
     */
    public function setGroundTrack($var)
    {
        GPBUtil::checkUint32($var);
        $this->ground_track = $var;

        return $this;
    }

    /**
     *
     * GPS fix quality (from NMEA GxGGA statement or similar)
     *
     * Generated from protobuf field <code>uint32 fix_quality = 17;</code>
     * @return int
     */
    public function getFixQuality()
    {
        return $this->fix_quality;
    }

    /**
     *
     * GPS fix quality (from NMEA GxGGA statement or similar)
     *
     * Generated from protobuf field <code>uint32 fix_quality = 17;</code>
     * @param int $var
     * @return $this
     */
    public function setFixQuality($var)
    {
        GPBUtil::checkUint32($var);
        $this->fix_quality = $var;

        return $this;
    }

    /**
     *
     * GPS fix type 2D/3D (from NMEA GxGSA statement)
     *
     * Generated from protobuf field <code>uint32 fix_type = 18;</code>
     * @return int
     */
    public function getFixType()
    {
        return $this->fix_type;
    }

    /**
     *
     * GPS fix type 2D/3D (from NMEA GxGSA statement)
     *
     * Generated from protobuf field <code>uint32 fix_type = 18;</code>
     * @param int $var
     * @return $this
     */
    public function setFixType($var)
    {
        GPBUtil::checkUint32($var);
        $this->fix_type = $var;

        return $this;
    }

    /**
     *
     * GPS "Satellites in View" number
     *
     * Generated from protobuf field <code>uint32 sats_in_view = 19;</code>
     * @return int
     */
    public function getSatsInView()
    {
        return $this->sats_in_view;
    }

    /**
     *
     * GPS "Satellites in View" number
     *
     * Generated from protobuf field <code>uint32 sats_in_view = 19;</code>
     * @param int $var
     * @return $this
     */
    public function setSatsInView($var)
    {
        GPBUtil::checkUint32($var);
        $this->sats_in_view = $var;

        return $this;
    }

    /**
     *
     * Sensor ID - in case multiple positioning sensors are being used
     *
     * Generated from protobuf field <code>uint32 sensor_id = 20;</code>
     * @return int
     */
    public function getSensorId()
    {
        return $this->sensor_id;
    }

    /**
     *
     * Sensor ID - in case multiple positioning sensors are being used
     *
     * Generated from protobuf field <code>uint32 sensor_id = 20;</code>
     * @param int $var
     * @return $this
     */
    public function setSensorId($var)
    {
        GPBUtil::checkUint32($var);
        $this->sensor_id = $var;

        return $this;
    }

    /**
     *
     * Estimated/expected time (in seconds) until next update:
     * - if we update at fixed intervals of X seconds, use X
     * - if we update at dynamic intervals (based on relative movement etc),
     *   but "AT LEAST every Y seconds", use Y
     *
     * Generated from protobuf field <code>uint32 next_update = 21;</code>
     * @return int
     */
    public function getNextUpdate()
    {
        return $this->next_update;
    }

    /**
     *
     * Estimated/expected time (in seconds) until next update:
     * - if we update at fixed intervals of X seconds, use X
     * - if we update at dynamic intervals (based on relative movement etc),
     *   but "AT LEAST every Y seconds", use Y
     *
     * Generated from protobuf field <code>uint32 next_update = 21;</code>
     * @param int $var
     * @return $this
     */
    public function setNextUpdate($var)
    {
        GPBUtil::checkUint32($var);
        $this->next_update = $var;

        return $this;
    }

    /**
     *
     * A sequence number, incremented with each Position message to help
     *   detect lost updates if needed
     *
     * Generated from protobuf field <code>uint32 seq_number = 22;</code>
     * @return int
     */
    public function getSeqNumber()
    {
        return $this->seq_number;
    }

    /**
     *
     * A sequence number, incremented with each Position message to help
     *   detect lost updates if needed
     *
     * Generated from protobuf field <code>uint32 seq_number = 22;</code>
     * @param int $var
     * @return $this
     */
    public function setSeqNumber($var)
    {
        GPBUtil::checkUint32($var);
        $this->seq_number = $var;

        return $this;
    }

}

