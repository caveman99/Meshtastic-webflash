<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: config.proto

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 *
 * Lora Config
 *
 * Generated from protobuf message <code>Config.LoRaConfig</code>
 */
class Config_LoRaConfig extends \Google\Protobuf\Internal\Message
{
    /**
     *
     * When enabled, the `modem_preset` fields will be adheared to, else the `bandwidth`/`spread_factor`/`coding_rate`
     * will be taked from their respective manually defined fields
     *
     * Generated from protobuf field <code>bool use_preset = 1;</code>
     */
    private $use_preset = false;
    /**
     *
     * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
     * As a heuristic: If bandwidth is specified, do not use modem_config.
     * Because protobufs take ZERO space when the value is zero this works out nicely.
     * This value is replaced by bandwidth/spread_factor/coding_rate.
     * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
     */
    private $modem_preset = 0;
    /**
     *
     * Bandwidth in MHz
     * Certain bandwidth numbers are 'special' and will be converted to the
     * appropriate floating point value: 31 -> 31.25MHz
     *
     * Generated from protobuf field <code>uint32 bandwidth = 3;</code>
     */
    private $bandwidth = 0;
    /**
     *
     * A number from 7 to 12.
     * Indicates number of chirps per symbol as 1<<spread_factor.
     *
     * Generated from protobuf field <code>uint32 spread_factor = 4;</code>
     */
    private $spread_factor = 0;
    /**
     *
     * The denominator of the coding rate.
     * ie for 4/5, the value is 5. 4/8 the value is 8.
     *
     * Generated from protobuf field <code>uint32 coding_rate = 5;</code>
     */
    private $coding_rate = 0;
    /**
     *
     * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
     * A frequency offset that is added to to the calculated band center frequency.
     * Used to correct for crystal calibration errors.
     *
     * Generated from protobuf field <code>float frequency_offset = 6;</code>
     */
    private $frequency_offset = 0.0;
    /**
     *
     * The region code for the radio (US, CN, EU433, etc...)
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.RegionCode region = 7;</code>
     */
    private $region = 0;
    /**
     *
     * Maximum number of hops. This can't be greater than 7.
     * Default of 3
     *
     * Generated from protobuf field <code>uint32 hop_limit = 8;</code>
     */
    private $hop_limit = 0;
    /**
     *
     * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
     * Defaults to false
     *
     * Generated from protobuf field <code>bool tx_enabled = 9;</code>
     */
    private $tx_enabled = false;
    /**
     *
     * If zero then, use default max legal continuous power (ie. something that won't
     * burn out the radio hardware)
     * In most cases you should use zero here.
     * Units are in dBm.
     *
     * Generated from protobuf field <code>int32 tx_power = 10;</code>
     */
    private $tx_power = 0;
    /**
     *
     * This is controlling the actual hardware frequency the radio is transmitting on.
     * Most users should never need to be exposed to this field/concept.
     * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
     * If ZERO then the rule is "use the old channel name hash based
     * algorithm to derive the channel number")
     * If using the hash algorithm the channel number will be: hash(channel_name) %
     * NUM_CHANNELS (Where num channels depends on the regulatory region).
     *
     * Generated from protobuf field <code>uint32 channel_num = 11;</code>
     */
    private $channel_num = 0;
    /**
     *
     * For testing it is useful sometimes to force a node to never listen to
     * particular other nodes (simulating radio out of range). All nodenums listed
     * in ignore_incoming will have packets they send droped on receive (by router.cpp)
     *
     * Generated from protobuf field <code>repeated uint32 ignore_incoming = 103;</code>
     */
    private $ignore_incoming;

    public function __construct() {
        \GPBMetadata\Config::initOnce();
        parent::__construct();
    }

    /**
     *
     * When enabled, the `modem_preset` fields will be adheared to, else the `bandwidth`/`spread_factor`/`coding_rate`
     * will be taked from their respective manually defined fields
     *
     * Generated from protobuf field <code>bool use_preset = 1;</code>
     * @return bool
     */
    public function getUsePreset()
    {
        return $this->use_preset;
    }

    /**
     *
     * When enabled, the `modem_preset` fields will be adheared to, else the `bandwidth`/`spread_factor`/`coding_rate`
     * will be taked from their respective manually defined fields
     *
     * Generated from protobuf field <code>bool use_preset = 1;</code>
     * @param bool $var
     * @return $this
     */
    public function setUsePreset($var)
    {
        GPBUtil::checkBool($var);
        $this->use_preset = $var;

        return $this;
    }

    /**
     *
     * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
     * As a heuristic: If bandwidth is specified, do not use modem_config.
     * Because protobufs take ZERO space when the value is zero this works out nicely.
     * This value is replaced by bandwidth/spread_factor/coding_rate.
     * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
     * @return int
     */
    public function getModemPreset()
    {
        return $this->modem_preset;
    }

    /**
     *
     * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
     * As a heuristic: If bandwidth is specified, do not use modem_config.
     * Because protobufs take ZERO space when the value is zero this works out nicely.
     * This value is replaced by bandwidth/spread_factor/coding_rate.
     * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setModemPreset($var)
    {
        GPBUtil::checkEnum($var, \Config_LoRaConfig_ModemPreset::class);
        $this->modem_preset = $var;

        return $this;
    }

    /**
     *
     * Bandwidth in MHz
     * Certain bandwidth numbers are 'special' and will be converted to the
     * appropriate floating point value: 31 -> 31.25MHz
     *
     * Generated from protobuf field <code>uint32 bandwidth = 3;</code>
     * @return int
     */
    public function getBandwidth()
    {
        return $this->bandwidth;
    }

    /**
     *
     * Bandwidth in MHz
     * Certain bandwidth numbers are 'special' and will be converted to the
     * appropriate floating point value: 31 -> 31.25MHz
     *
     * Generated from protobuf field <code>uint32 bandwidth = 3;</code>
     * @param int $var
     * @return $this
     */
    public function setBandwidth($var)
    {
        GPBUtil::checkUint32($var);
        $this->bandwidth = $var;

        return $this;
    }

    /**
     *
     * A number from 7 to 12.
     * Indicates number of chirps per symbol as 1<<spread_factor.
     *
     * Generated from protobuf field <code>uint32 spread_factor = 4;</code>
     * @return int
     */
    public function getSpreadFactor()
    {
        return $this->spread_factor;
    }

    /**
     *
     * A number from 7 to 12.
     * Indicates number of chirps per symbol as 1<<spread_factor.
     *
     * Generated from protobuf field <code>uint32 spread_factor = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setSpreadFactor($var)
    {
        GPBUtil::checkUint32($var);
        $this->spread_factor = $var;

        return $this;
    }

    /**
     *
     * The denominator of the coding rate.
     * ie for 4/5, the value is 5. 4/8 the value is 8.
     *
     * Generated from protobuf field <code>uint32 coding_rate = 5;</code>
     * @return int
     */
    public function getCodingRate()
    {
        return $this->coding_rate;
    }

    /**
     *
     * The denominator of the coding rate.
     * ie for 4/5, the value is 5. 4/8 the value is 8.
     *
     * Generated from protobuf field <code>uint32 coding_rate = 5;</code>
     * @param int $var
     * @return $this
     */
    public function setCodingRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->coding_rate = $var;

        return $this;
    }

    /**
     *
     * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
     * A frequency offset that is added to to the calculated band center frequency.
     * Used to correct for crystal calibration errors.
     *
     * Generated from protobuf field <code>float frequency_offset = 6;</code>
     * @return float
     */
    public function getFrequencyOffset()
    {
        return $this->frequency_offset;
    }

    /**
     *
     * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
     * A frequency offset that is added to to the calculated band center frequency.
     * Used to correct for crystal calibration errors.
     *
     * Generated from protobuf field <code>float frequency_offset = 6;</code>
     * @param float $var
     * @return $this
     */
    public function setFrequencyOffset($var)
    {
        GPBUtil::checkFloat($var);
        $this->frequency_offset = $var;

        return $this;
    }

    /**
     *
     * The region code for the radio (US, CN, EU433, etc...)
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.RegionCode region = 7;</code>
     * @return int
     */
    public function getRegion()
    {
        return $this->region;
    }

    /**
     *
     * The region code for the radio (US, CN, EU433, etc...)
     *
     * Generated from protobuf field <code>.Config.LoRaConfig.RegionCode region = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setRegion($var)
    {
        GPBUtil::checkEnum($var, \Config_LoRaConfig_RegionCode::class);
        $this->region = $var;

        return $this;
    }

    /**
     *
     * Maximum number of hops. This can't be greater than 7.
     * Default of 3
     *
     * Generated from protobuf field <code>uint32 hop_limit = 8;</code>
     * @return int
     */
    public function getHopLimit()
    {
        return $this->hop_limit;
    }

    /**
     *
     * Maximum number of hops. This can't be greater than 7.
     * Default of 3
     *
     * Generated from protobuf field <code>uint32 hop_limit = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setHopLimit($var)
    {
        GPBUtil::checkUint32($var);
        $this->hop_limit = $var;

        return $this;
    }

    /**
     *
     * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
     * Defaults to false
     *
     * Generated from protobuf field <code>bool tx_enabled = 9;</code>
     * @return bool
     */
    public function getTxEnabled()
    {
        return $this->tx_enabled;
    }

    /**
     *
     * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
     * Defaults to false
     *
     * Generated from protobuf field <code>bool tx_enabled = 9;</code>
     * @param bool $var
     * @return $this
     */
    public function setTxEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->tx_enabled = $var;

        return $this;
    }

    /**
     *
     * If zero then, use default max legal continuous power (ie. something that won't
     * burn out the radio hardware)
     * In most cases you should use zero here.
     * Units are in dBm.
     *
     * Generated from protobuf field <code>int32 tx_power = 10;</code>
     * @return int
     */
    public function getTxPower()
    {
        return $this->tx_power;
    }

    /**
     *
     * If zero then, use default max legal continuous power (ie. something that won't
     * burn out the radio hardware)
     * In most cases you should use zero here.
     * Units are in dBm.
     *
     * Generated from protobuf field <code>int32 tx_power = 10;</code>
     * @param int $var
     * @return $this
     */
    public function setTxPower($var)
    {
        GPBUtil::checkInt32($var);
        $this->tx_power = $var;

        return $this;
    }

    /**
     *
     * This is controlling the actual hardware frequency the radio is transmitting on.
     * Most users should never need to be exposed to this field/concept.
     * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
     * If ZERO then the rule is "use the old channel name hash based
     * algorithm to derive the channel number")
     * If using the hash algorithm the channel number will be: hash(channel_name) %
     * NUM_CHANNELS (Where num channels depends on the regulatory region).
     *
     * Generated from protobuf field <code>uint32 channel_num = 11;</code>
     * @return int
     */
    public function getChannelNum()
    {
        return $this->channel_num;
    }

    /**
     *
     * This is controlling the actual hardware frequency the radio is transmitting on.
     * Most users should never need to be exposed to this field/concept.
     * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
     * If ZERO then the rule is "use the old channel name hash based
     * algorithm to derive the channel number")
     * If using the hash algorithm the channel number will be: hash(channel_name) %
     * NUM_CHANNELS (Where num channels depends on the regulatory region).
     *
     * Generated from protobuf field <code>uint32 channel_num = 11;</code>
     * @param int $var
     * @return $this
     */
    public function setChannelNum($var)
    {
        GPBUtil::checkUint32($var);
        $this->channel_num = $var;

        return $this;
    }

    /**
     *
     * For testing it is useful sometimes to force a node to never listen to
     * particular other nodes (simulating radio out of range). All nodenums listed
     * in ignore_incoming will have packets they send droped on receive (by router.cpp)
     *
     * Generated from protobuf field <code>repeated uint32 ignore_incoming = 103;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getIgnoreIncoming()
    {
        return $this->ignore_incoming;
    }

    /**
     *
     * For testing it is useful sometimes to force a node to never listen to
     * particular other nodes (simulating radio out of range). All nodenums listed
     * in ignore_incoming will have packets they send droped on receive (by router.cpp)
     *
     * Generated from protobuf field <code>repeated uint32 ignore_incoming = 103;</code>
     * @param int[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setIgnoreIncoming($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT32);
        $this->ignore_incoming = $arr;

        return $this;
    }

}

