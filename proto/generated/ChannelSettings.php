<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: channel.proto

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 *
 * Full settings (center freq, spread factor, pre-shared secret key etc...)
 * needed to configure a radio for speaking on a particular channel This
 * information can be encoded as a QRcode/url so that other users can configure
 * their radio to join the same channel.
 * A note about how channel names are shown to users: channelname-Xy
 * poundsymbol is a prefix used to indicate this is a channel name (idea from &#64;professr).
 * Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
 * channel - so that if the user changes anything about the channel (which does
 * force a new PSK) this letter will also change. Thus preventing user confusion if
 * two friends try to type in a channel name of "BobsChan" and then can't talk
 * because their PSKs will be different.
 * The PSK is hashed into this letter by "0x41 + [xor all bytes of the psk ] modulo 26"
 * This also allows the option of someday if people have the PSK off (zero), the
 * users COULD type in a channel name and be able to talk.
 * Y is a lower case letter from a-z that represents the channel 'speed' settings
 * (for some future definition of speed)
 * FIXME: Add description of multi-channel support and how primary vs secondary channels are used.
 * FIXME: explain how apps use channels for security.
 * explain how remote settings and remote gpio are managed as an example
 *
 * Generated from protobuf message <code>ChannelSettings</code>
 */
class ChannelSettings extends \Google\Protobuf\Internal\Message
{
    /**
     *
     * Deprecated in favor of LoraConfig.channel_num
     *
     * Generated from protobuf field <code>uint32 channel_num = 1 [deprecated = true];</code>
     */
    private $channel_num = 0;
    /**
     *
     * A simple pre-shared key for now for crypto.
     * Must be either 0 bytes (no crypto), 16 bytes (AES128), or 32 bytes (AES256).
     * A special shorthand is used for 1 byte long psks.
     * These psks should be treated as only minimally secure,
     * because they are listed in this source code.
     * Those bytes are mapped using the following scheme:
     * `0` = No crypto
     * `1` = The special "default" channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
     * `2` through 10 = The default channel key, except with 1 through 9 added to the last byte.
     * Shown to user as simple1 through 10
     *
     * Generated from protobuf field <code>bytes psk = 2;</code>
     */
    private $psk = '';
    /**
     *
     * A SHORT name that will be packed into the URL.
     * Less than 12 bytes.
     * Something for end users to call the channel
     * If this is the empty string it is assumed that this channel
     * is the special (minimally secure) "Default"channel.
     * In user interfaces it should be rendered as a local language translation of "X".
     * For channel_num hashing empty string will be treated as "X".
     * Where "X" is selected based on the English words listed above for ModemPreset
     *
     * Generated from protobuf field <code>string name = 3;</code>
     */
    private $name = '';
    /**
     *
     * Used to construct a globally unique channel ID.
     * The full globally unique ID will be: "name.id" where ID is shown as base36.
     * Assuming that the number of meshtastic users is below 20K (true for a long time)
     * the chance of this 64 bit random number colliding with anyone else is super low.
     * And the penalty for collision is low as well, it just means that anyone trying to decrypt channel messages might need to
     * try multiple candidate channels.
     * Any time a non wire compatible change is made to a channel, this field should be regenerated.
     * There are a small number of 'special' globally known (and fairly) insecure standard channels.
     * Those channels do not have a numeric id included in the settings, but instead it is pulled from
     * a table of well known IDs.
     * (see Well Known Channels FIXME)
     *
     * Generated from protobuf field <code>fixed32 id = 4;</code>
     */
    private $id = 0;
    /**
     *
     * If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
     *
     * Generated from protobuf field <code>bool uplink_enabled = 5;</code>
     */
    private $uplink_enabled = false;
    /**
     *
     * If true, messages seen on the internet will be forwarded to the local mesh.
     *
     * Generated from protobuf field <code>bool downlink_enabled = 6;</code>
     */
    private $downlink_enabled = false;

    public function __construct() {
        \GPBMetadata\Channel::initOnce();
        parent::__construct();
    }

    /**
     *
     * Deprecated in favor of LoraConfig.channel_num
     *
     * Generated from protobuf field <code>uint32 channel_num = 1 [deprecated = true];</code>
     * @return int
     */
    public function getChannelNum()
    {
        return $this->channel_num;
    }

    /**
     *
     * Deprecated in favor of LoraConfig.channel_num
     *
     * Generated from protobuf field <code>uint32 channel_num = 1 [deprecated = true];</code>
     * @param int $var
     * @return $this
     */
    public function setChannelNum($var)
    {
        GPBUtil::checkUint32($var);
        $this->channel_num = $var;

        return $this;
    }

    /**
     *
     * A simple pre-shared key for now for crypto.
     * Must be either 0 bytes (no crypto), 16 bytes (AES128), or 32 bytes (AES256).
     * A special shorthand is used for 1 byte long psks.
     * These psks should be treated as only minimally secure,
     * because they are listed in this source code.
     * Those bytes are mapped using the following scheme:
     * `0` = No crypto
     * `1` = The special "default" channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
     * `2` through 10 = The default channel key, except with 1 through 9 added to the last byte.
     * Shown to user as simple1 through 10
     *
     * Generated from protobuf field <code>bytes psk = 2;</code>
     * @return string
     */
    public function getPsk()
    {
        return $this->psk;
    }

    /**
     *
     * A simple pre-shared key for now for crypto.
     * Must be either 0 bytes (no crypto), 16 bytes (AES128), or 32 bytes (AES256).
     * A special shorthand is used for 1 byte long psks.
     * These psks should be treated as only minimally secure,
     * because they are listed in this source code.
     * Those bytes are mapped using the following scheme:
     * `0` = No crypto
     * `1` = The special "default" channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
     * `2` through 10 = The default channel key, except with 1 through 9 added to the last byte.
     * Shown to user as simple1 through 10
     *
     * Generated from protobuf field <code>bytes psk = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setPsk($var)
    {
        GPBUtil::checkString($var, False);
        $this->psk = $var;

        return $this;
    }

    /**
     *
     * A SHORT name that will be packed into the URL.
     * Less than 12 bytes.
     * Something for end users to call the channel
     * If this is the empty string it is assumed that this channel
     * is the special (minimally secure) "Default"channel.
     * In user interfaces it should be rendered as a local language translation of "X".
     * For channel_num hashing empty string will be treated as "X".
     * Where "X" is selected based on the English words listed above for ModemPreset
     *
     * Generated from protobuf field <code>string name = 3;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     *
     * A SHORT name that will be packed into the URL.
     * Less than 12 bytes.
     * Something for end users to call the channel
     * If this is the empty string it is assumed that this channel
     * is the special (minimally secure) "Default"channel.
     * In user interfaces it should be rendered as a local language translation of "X".
     * For channel_num hashing empty string will be treated as "X".
     * Where "X" is selected based on the English words listed above for ModemPreset
     *
     * Generated from protobuf field <code>string name = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     *
     * Used to construct a globally unique channel ID.
     * The full globally unique ID will be: "name.id" where ID is shown as base36.
     * Assuming that the number of meshtastic users is below 20K (true for a long time)
     * the chance of this 64 bit random number colliding with anyone else is super low.
     * And the penalty for collision is low as well, it just means that anyone trying to decrypt channel messages might need to
     * try multiple candidate channels.
     * Any time a non wire compatible change is made to a channel, this field should be regenerated.
     * There are a small number of 'special' globally known (and fairly) insecure standard channels.
     * Those channels do not have a numeric id included in the settings, but instead it is pulled from
     * a table of well known IDs.
     * (see Well Known Channels FIXME)
     *
     * Generated from protobuf field <code>fixed32 id = 4;</code>
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     *
     * Used to construct a globally unique channel ID.
     * The full globally unique ID will be: "name.id" where ID is shown as base36.
     * Assuming that the number of meshtastic users is below 20K (true for a long time)
     * the chance of this 64 bit random number colliding with anyone else is super low.
     * And the penalty for collision is low as well, it just means that anyone trying to decrypt channel messages might need to
     * try multiple candidate channels.
     * Any time a non wire compatible change is made to a channel, this field should be regenerated.
     * There are a small number of 'special' globally known (and fairly) insecure standard channels.
     * Those channels do not have a numeric id included in the settings, but instead it is pulled from
     * a table of well known IDs.
     * (see Well Known Channels FIXME)
     *
     * Generated from protobuf field <code>fixed32 id = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setId($var)
    {
        GPBUtil::checkUint32($var);
        $this->id = $var;

        return $this;
    }

    /**
     *
     * If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
     *
     * Generated from protobuf field <code>bool uplink_enabled = 5;</code>
     * @return bool
     */
    public function getUplinkEnabled()
    {
        return $this->uplink_enabled;
    }

    /**
     *
     * If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
     *
     * Generated from protobuf field <code>bool uplink_enabled = 5;</code>
     * @param bool $var
     * @return $this
     */
    public function setUplinkEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->uplink_enabled = $var;

        return $this;
    }

    /**
     *
     * If true, messages seen on the internet will be forwarded to the local mesh.
     *
     * Generated from protobuf field <code>bool downlink_enabled = 6;</code>
     * @return bool
     */
    public function getDownlinkEnabled()
    {
        return $this->downlink_enabled;
    }

    /**
     *
     * If true, messages seen on the internet will be forwarded to the local mesh.
     *
     * Generated from protobuf field <code>bool downlink_enabled = 6;</code>
     * @param bool $var
     * @return $this
     */
    public function setDownlinkEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->downlink_enabled = $var;

        return $this;
    }

}

